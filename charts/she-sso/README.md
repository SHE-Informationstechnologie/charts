# she-sso

![Version: 0.0.12](https://img.shields.io/badge/Version-0.0.12-informational?style=flat-square) ![Type: application](https://img.shields.io/badge/Type-application-informational?style=flat-square) ![AppVersion: 0.0.12](https://img.shields.io/badge/AppVersion-0.0.12-informational?style=flat-square)

Integration internal cluster services into SHE SSO

## Requirements

| Repository | Name | Version |
|------------|------|---------|
| oci://registry-1.docker.io/bitnamicharts | redis | 24.1.0 |

## Values

| Key | Type | Default | Description |
|-----|------|---------|-------------|
| argocd.annotations."app.kubernetes.io/part-of" | string | `"argocd"` |  |
| argocd.config.cm."admin.enabled" | string | `"true"` |  |
| argocd.config.cm."application.instanceLabelKey" | string | `"argocd.argoproj.io/instance"` |  |
| argocd.config.cm."exec.enabled" | string | `"false"` |  |
| argocd.config.cm."oidc.config" | string | `"\n# This name will be shown on the button used to start the SSO process\nname: \"Example SSO\"\n\n# Name of the oidc client configured in (e.g. keycloak)\nclientID: client-id\n\n# Reference to the ArgoCD internal secret value for the oidc client secret\n# This will be provided by a pre-existing sealed secret\n# (please check the manual installation steps or the 'manual/secrets' directory)\n# In most cases this shouldn't be changed\nclientSecret: $oidc.keycloak.clientSecret\n\n# Pattern: https://<url of keycloak>/realms/<realm>\n# Hint: In case the keycloak version is below 18.0.0 use this pattern:\n# Pattern: https://<url of keycloak>/auth/realms/<realm>\nissuer: https://sso.example.com/realms/example\n\n# Skip audience check if token doesn't provide a audience setting\nskipAudienceCheckWhenTokenHasNoAudience: true\n\n# Request following scopes\nrequestedScopes: [\"openid\", \"profile\", \"email\", \"roles\"]\n\n# Make sure the roles are part of the ID token\nrequestedIDTokenClaims: {\"roles\": {\"essential\": true}}\n\n# If using selfsigned certificates you got two options\n# 1. Add the root CA with this setting\n# 2. Enable the setting 'oidc.tls.insecure.skip.verify' setting and ignore invalid certificates\n# rootCA: |\n#   ------BEGIN CERTIFICATE-----\n#   eW91IGhhdmUgdG9vIG11Y2ggZnJlZSB0aW1l\n#   -----END CERTIFICATE-----\n"` |  |
| argocd.config.cm."oidc.tls.insecure.skip.verify" | string | `"true"` |  |
| argocd.config.cm."server.rbac.log.enforce.enable" | string | `"false"` |  |
| argocd.config.cm."timeout.hard.reconciliation" | string | `"0s"` |  |
| argocd.config.cm."timeout.reconciliation" | string | `"180s"` |  |
| argocd.config.cm.url | string | `"https://argocd.example.com"` |  |
| argocd.config.rbac."policy.csv" | string | `"g, devops_admin, role:admin\n"` |  |
| argocd.config.rbac."policy.default" | string | `"role:readonly"` |  |
| argocd.config.rbac.scopes | string | `"[roles]"` |  |
| argocd.enabled | bool | `true` |  |
| oAuthProxy.config.configFile | string | `"# Since the SHE SSO is using a keycloak this should stay the same\nprovider = \"keycloak-oidc\"\n\n# Can be replaced by an exact list of valid email domains used by users\nemail_domains = [ \"*\" ]\n\n# Should be replaced by a domain covering all services\ncookie_domains = \".example.org\"\ncookie_secure = \"true\"\n\n# If using keycloak this should match following pattern\n# Pattern: https://<url of keycloak>/realms/<realm>\n# Hint: In case the keycloak version is below 18.0.0 use this pattern:\n# Pattern: https://<url of keycloak>/auth/realms/<realm>\noidc_issuer_url = \"https://sso.example.org/realms/example\"\n\n# The user will be sent back to this URL after authentication\n# It needs to be configured in the oidc client as a valid redirect URL\n# In most cases this should stay the same\n# Please be aware, that the '{{url}}' part is a templating used in the argocd applicationset\n# generated by this chart. So please replace it.\nredirect_url = \"https://{{url}}/oauth2/callback\"\n\n# Challenge used during authentication\ncode_challenge_method = \"S256\"\n\n# If using selfsigned certificates you got two options\n# 1. Enable this setting and ignore the selfsigned certificate\n# 2. Add the root CA with the 'rootCA' setting\nssl_insecure_skip_verify = \"true\"\n\n# rootCA: |\n#   ------BEGIN CERTIFICATE-----\n#   eW91IGhhdmUgdG9vIG11Y2ggZnJlZSB0aW1l\n#   -----END CERTIFICATE-----\n\n# Let the oauth2 proxy set the 'Authorization'-header for the upstream service\nset_authorization_header = \"true\"\n"` |  |
| oAuthProxy.config.existingSecret | string | `"secret-config"` |  |
| oAuthProxy.image.repository | string | `"quay.io/oauth2-proxy/oauth2-proxy"` |  |
| oAuthProxy.imagePullSecrets | list | `[]` |  |
| oAuthProxy.redis.connectionUrl | string | `"redis://redis-master.default.svc.cluster.local:6379"` |  |
| oAuthProxy.redis.existingSecret | string | `"redis-password"` |  |
| oAuthProxy.redis.passwordKey | string | `"password"` |  |
| oAuthProxy.source.chart | string | `"oauth2-proxy"` |  |
| oAuthProxy.source.repoURL | string | `"https://oauth2-proxy.github.io/manifests"` |  |
| oAuthProxy.source.targetRevision | string | `"6.23.1"` |  |
| oAuthProxyServices | list | `[]` |  |
| redis.auth.existingSecret | string | `"redis-password"` |  |
| redis.auth.existingSecretPasswordKey | string | `"password"` |  |
| redis.enabled | bool | `true` |  |
| redis.image.pullSecrets | list | `[]` |  |
| redis.image.registry | string | `"docker.io"` |  |

----------------------------------------------
