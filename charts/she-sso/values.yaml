# List of services for which an oauth2 proxy will be deployed
oAuthProxyServices: []
  #   # Name of oauth2 proxy
  #   # As long as you don't use 'overwriteName' this will be used as base resource names
  # - name: alertmanager
  #   # namespace: monitoring
  #
  #   # Deploy an ingress resource for this oauth2 proxy
  #   # Please be aware that it needs to match the exact host of the covered service
  #   ingress:
  #     # Deploy an ingress resource pointing to the oauth2 proxy
  #     enabled: true
  #     # overwriteName: alertmanager-replace
  #
  #     # List of URLs this oauth2 proxy will cover
  #     hosts:
  #       - host: alertmanager.example.com
  #         path: /oauth2
  #
  #     tls:
  #       - hosts:
  #           - alertmanager.example.com
  #   service:
  #     enabled: true
  #     # overwriteName: alternative-alertmanager

# General settings for the oauth2 proxie
oAuthProxy:

  # Source of the Helm chart
  source:
    repoURL: https://oauth2-proxy.github.io/manifests
    chart: oauth2-proxy
    targetRevision: 6.23.1

  # Image settings
  image:
    repository: quay.io/oauth2-proxy/oauth2-proxy
  imagePullSecrets: []

  # Each oauth2 proxie needs a redis cluster for as storage
  redis:
    # The redis password should be stored in an already existing secret
    # (please check the manual installation steps or the 'manual/secrets' directory)
    existingSecret: redis-password

    # Key within the secret which contains the password used to access redis
    passwordKey: password

    # URI of the redis cluster
    connectionUrl: redis://redis-master.default.svc.cluster.local:6379

  # Configuration splitted in sensitive (in secret) and public (in configmap) part
  config:
    # The sensitive config should be already existing
    # (please check the manual installation steps or the 'manual/secrets' directory)
    existingSecret: secret-config

    # OpenID Connect settings
    configFile: |
      # Since the SHE SSO is using a keycloak this should stay the same
      provider = "keycloak-oidc"

      # Can be replaced by an exact list of valid email domains used by users
      email_domains = [ "*" ]

      # Should be replaced by a domain covering all services
      cookie_domains = ".example.org"
      cookie_secure = "true"

      # If using keycloak this should match following pattern
      # Pattern: https://<url of keycloak>/realms/<realm>
      # Hint: In case the keycloak version is below 18.0.0 use this pattern:
      # Pattern: https://<url of keycloak>/auth/realms/<realm>
      oidc_issuer_url = "https://sso.example.org/realms/example"

      # The user will be sent back to this URL after authentication
      # It needs to be configured in the oidc client as a valid redirect URL
      # In most cases this should stay the same
      # Please be aware, that the '{{url}}' part is a templating used in the argocd applicationset
      # generated by this chart. So please replace it.
      redirect_url = "https://{{url}}/oauth2/callback"

      # Challenge used during authentication
      code_challenge_method = "S256"

      # If using selfsigned certificates you got two options
      # 1. Enable this setting and ignore the selfsigned certificate
      # 2. Add the root CA with the 'rootCA' setting
      ssl_insecure_skip_verify = "true"

      # rootCA: |
      #   ------BEGIN CERTIFICATE-----
      #   eW91IGhhdmUgdG9vIG11Y2ggZnJlZSB0aW1l
      #   -----END CERTIFICATE-----

      # Let the oauth2 proxy set the 'Authorization'-header for the upstream service
      set_authorization_header = "true"

# Setting specific for the ArgoCD oidc integration
argocd:
  enabled: true

  # Namespace in which the ArgoCD is deployed
  # namespace: argocd

  # This annotations will be attached to each ArgoCD specific resource
  # Since we are replacing configmaps typically generated by ArgoCD, this annotation
  # needs to be present to allow ArgoCD to find it
  annotations:
    app.kubernetes.io/part-of: argocd

  # Overwrite configuration and add e.g. oidc settings or a RBAC mapping
  config:
    cm:
      admin.enabled: "true"
      application.instanceLabelKey: argocd.argoproj.io/instance
      exec.enabled: "false"

      # OIDC settings
      oidc.config: |

        # This name will be shown on the button used to start the SSO process
        name: "Example SSO"

        # Name of the oidc client configured in (e.g. keycloak)
        clientID: client-id

        # Reference to the ArgoCD internal secret value for the oidc client secret
        # This will be provided by a pre-existing sealed secret
        # (please check the manual installation steps or the 'manual/secrets' directory)
        # In most cases this shouldn't be changed
        clientSecret: $oidc.keycloak.clientSecret

        # Pattern: https://<url of keycloak>/realms/<realm>
        # Hint: In case the keycloak version is below 18.0.0 use this pattern:
        # Pattern: https://<url of keycloak>/auth/realms/<realm>
        issuer: https://sso.example.com/realms/example

        # Skip audience check if token doesn't provide a audience setting
        skipAudienceCheckWhenTokenHasNoAudience: true

        # Request following scopes
        requestedScopes: ["openid", "profile", "email", "roles"]

        # Make sure the roles are part of the ID token
        requestedIDTokenClaims: {"roles": {"essential": true}}

        # If using selfsigned certificates you got two options
        # 1. Add the root CA with this setting
        # 2. Enable the setting 'oidc.tls.insecure.skip.verify' setting and ignore invalid certificates
        # rootCA: |
        #   ------BEGIN CERTIFICATE-----
        #   eW91IGhhdmUgdG9vIG11Y2ggZnJlZSB0aW1l
        #   -----END CERTIFICATE-----

      # Enable this setting and ignore the selfsigned certificate (see above)
      oidc.tls.insecure.skip.verify: "true"

      # Disable RBAC violation logging
      server.rbac.log.enforce.enable: "false"

      # Timeout settings
      timeout.hard.reconciliation: 0s
      timeout.reconciliation: 180s

      # URL of the argocd service
      url: https://argocd.example.com

    # RBAC mapping settings
    # (please check: https://argo-cd.readthedocs.io/en/stable/operator-manual/rbac/)
    rbac:
      policy.csv: |
        g, devops_admin, role:admin
      policy.default: role:readonly
      scopes: '[roles]'

# The oAuth proxies need a redis based storage for meta-/cookiedata
# This settings configure the redis cluster
redis:
  enabled: true

  # Image settings
  image:
    registry: docker.io
    pullSecrets: []

  # Don't allow redis to generated a new password during deployment
  # Use an existing one instead
  auth:
    # The redis password should be stored in an already existing secret
    # (please check the manual installation steps or the 'manual/secrets' directory)
    existingSecret: redis-password

    # Key within the secret which contains the password used to access redis
    existingSecretPasswordKey: password
